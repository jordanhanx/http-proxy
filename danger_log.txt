----------------------------
Robust to External Failures:
----------------------------
- If client send a malformed request to the proxy, our application will send back a 400 error message back to client.
- Also, if server send a corrupted resposne, the application will also send a 502 error message to inform client.


----------------------------
Cache Policy:
----------------------------
When our application acts like server to receive request from client:
1. If proxy receive a GET request, it will first look at cache to see if it has been cached
  a. if found, move to step 2
  b. if not found, 
    - log the not cacheable message into proxy.log
    - connect to server and get response from actual server
2. While found in the cache, check if this response need re-validate or is expired
  a. if don't need revalidate, and the response is not expired
    - log the valid in cache message into proxy.log
    - send the http resposne to client
  b. if need, 
    - log either expired time or need revalidate info into proxy.log
    - send the revalidation request to actual server, and get updated response from it

When our application acts like client to receive response from server:
1. If it's a 304 response, return the existing response in cache
2. If it's a 200 OK response, update/insert the cache and return it 

Cacheable Policy:
----------------------------
- if the cache-control field in response contains private or no store, it's not cacheable
- if max_age, expired_time is equal to -1, this cache is not cacheable

Revalidate Policy:
----------------------------
- if the cache-control field contains filed "no-cache" or "must-revalidate", it must be revalidate
- if current time passed the expired time (since we use library to parse it, and it provides expired time for us)
then, this http response needs revalidate.

Update Policy:
----------------------------
- if the response is been cached, then just locate the cached response, and update its value

Insert Policy
----------------------------
1. If the response is not been cached, then need to first figure out if it can be cached indicated by 
the cacheable policy. 
  a. If is not cacheble, log the message to proxy.log
  b. If can be cached, continue to step2
2. Follow the revalidate policy to check if this response need to be revalidate
  a. If yes, log the message to proxy.log
  b. Else, 
    - log the expired time in proxy.log /*------------------------------  ProxySession.cpp  ---------------------------------*/
#include "ProxySession.hpp"

std::atomic<size_t> ProxySession::next_request_id(1);

ProxySession::ProxySession(boost::asio::ip::tcp::socket socket, Logger & logger, Cache & cache) :
    client(std::move(socket)), server(socket.get_executor()), logger(logger), cache(cache){
  client_ip = client.remote_endpoint().address().to_string();
}

ProxySession::~ProxySession() {
}

void ProxySession::start() {
  recvReqFrClient();
}

void ProxySession::recvReqFrClient() {
  auto self = shared_from_this();
  request = {};
  boost::beast::http::async_read(
      client,
      buf,
      request,
      [this, self](boost::system::error_code ec, std::size_t /*length*/) {
        request.set("request_id", next_request_id);
        next_request_id++;
        if (!ec) {
          auto suffix_pos = request[boost::beast::http::field::host].rfind(":443");
          server_host =
              request[boost::beast::http::field::host].substr(0, suffix_pos).to_string();
          logger.logRecvReq(request["request_id"].to_string(),
                            request.method_string().to_string(),
                            request.target().to_string(),
                            request.version(),
                            client_ip);

          if (request.method() == boost::beast::http::verb::connect) {
            tunnel = std::unique_ptr<ConnectTunnel>(
                new ConnectTunnel(self,
                                  client,
                                  server,
                                  request["request_id"].to_string(),
                                  server_host,
                                  logger));
            tunnel->start();
          }
          else if (request.method() == boost::beast::http::verb::post) {
            connectOriginServer();
          }
          else if (request.method() == boost::beast::http::verb::get) {
            lookupCache();
          }
          else {
            std::cerr << "readReqFrClient() unsupported method:\n[" << request << "]\n";
          }
        }
        else {
          std::cerr << "readReqFrClient() ec: " << ec.message() << "\n[" << request
                    << "]\n";
          if (ec != boost::beast::http::error::end_of_stream) {
            send400ToClient();
          }
        }
      });
}

void ProxySession::sendReqToOriginServer() {
  auto self = shared_from_this();
  boost::beast::http::async_write(
      server,
      request,
      [this, self](boost::system::error_code ec, std::size_t /*length*/) {
        if (!ec) {
          logger.logRequesting(std::string(request["request_id"]),
                               request.method_string().to_string(),
                               request.target().to_string(),
                               request.version(),
                               server_host);
          recvResFrOriginServer();
        }
        else {
          std::cerr << "sendReqToOriginServer() ec: " << ec.message() << "\n";
        }
      });
}

void ProxySession::recvResFrOriginServer() {
  auto self = shared_from_this();
  response = {};
  boost::beast::http::async_read(
      server,
      buf,
      response,
      [this, self](boost::system::error_code ec, std::size_t /*length*/) {
        if (!ec) {
          response.set("request_id", request["request_id"]);
          logger.logRecvRes(response["request_id"].to_string(),
                            response.version(),
                            response.result_int(),
                            response.reason().to_string(),
                            server_host);
          updateCache();
        }
        else {
          std::cerr << "recvResFrOriginServer() ec: " << ec.message() << "\n["
                    << response.base() << "]\n";
          send502ToClient();
        }
      });
}

void ProxySession::sendResToClient() {
  auto self = shared_from_this();
  boost::beast::http::async_write(
      client,
      response,
      [this, self](boost::system::error_code ec, std::size_t /*length*/) {
        if (!ec) {
          logger.logResponding(response["request_id"].to_string(),
                               response.version(),
                               response.result_int(),
                               response.reason().to_string());
          // recvReqFrClient();
        }
        else {
          std::cerr << "sendResToClient() ec: " << ec.message() << "\n";
        }
      });
}

void ProxySession::connectOriginServer() {
  boost::system::error_code ec;
  // Make the connection on the IP address we get from a lookup
  auto ipResolver = boost::asio::ip::tcp::resolver(server.get_executor());
  auto endpoints = ipResolver.resolve(server_host, "http", ec);
  if (ec) {
    std::cerr << "connectOriginServer(" << server_host << ":80) ec: " << ec.message()
              << "\n";
  }
  auto self = shared_from_this();
  boost::asio::async_connect(
      server,
      endpoints,
      [this, self](boost::system::error_code ec, boost::asio::ip::tcp::endpoint ep) {
        if (!ec) {
          sendReqToOriginServer();
        }
        else {
          send400ToClient();
          std::cerr << "connectOriginServer(" << server_host
                    << ":80) ec: " << ec.message() << "\n";
          
        }
      });
}

void ProxySession::lookupCache() {
  if(!cache.checkResExist(request.target().to_string())){
    logger.log(request["request_id"].to_string() + ": not in cache");
    connectOriginServer();
  }else{
    if(cache.checkValidate(request.target().to_string(), logger)){
      response = cache.getResponse(request.target().to_string());
      sendResToClient();
    }else{
      request.set(http::field::if_modified_since, cache.getCahchedDate(request.target().to_string()));
      connectOriginServer();
    }
  }
}

void ProxySession::updateCache() {
  if(response.result_int() == 304){
    response = cache.updateResponse(response, request.target().to_string(), true, logger);
  }else{
    if(response.result_int() == 200){
      cache.updateResponse(response, request.target().to_string(), false, logger);
    }
  }
  sendResToClient();
}

void ProxySession::send400ToClient() {
  response = {};
  response.version(11);
  response.result(boost::beast::http::status::bad_request);
  response.body() = "HTTP/1.1 400 Bad Request";
  response.prepare_payload();
  sendResToClient();
}

void ProxySession::send502ToClient() {
  response = {};
  response.version(11);
  response.result(boost::beast::http::status::bad_gateway);
  response.body() = "HTTP/1.1 502 Bad Gateway";
  response.prepare_payload();
  sendResToClient();
}
/*------------------------------------  EOF  ---------------------------------------*/

    - insert the response to the Cache
3. If cache is full, our cache follows a first in first out(FIFO) to remove the first element stored in the cache


----------------------------
Handle Synchronization:
----------------------------
- we use lock-guard to protect cache for each read and write operation
- And we also have lock for our logger while writting every message



----------------------------
Exception Guarantees :
----------------------------
- We have a basic exception for all our classes.
- Since we implement our http proxy using Asio library, we will get updates on error code notification,
so we can handle these erros based on error code accordingly
- If there is an error detected while parsing the HTTP from server or client, our proxy will send a malformed error respect
to either a response or request